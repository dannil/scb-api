<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">scb-java-client</a> &gt; <a href="index.source.html" class="el_package">com.github.dannil.scbjavaclient.utility</a> &gt; <span class="el_source">QueryBuilder.java</span></div><h1>QueryBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Daniel Nilsson
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.dannil.scbjavaclient.utility;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;

/**
 * Class which is responsible for constructing the query which should be sent to the SCB API.
 * 
 * @author Daniel Nilsson
 *
 */
public final class QueryBuilder {

	/**
	 * Private constructor to prevent instantiation.
	 */
<span class="fc" id="L38">	private QueryBuilder() {</span>

<span class="fc" id="L40">	}</span>

	/**
	 * Filter out the specified value from the input collection.
	 * 
	 * @param collection
	 *            the collection to filter
	 * @param value
	 *            the value to remove from the collection
	 * @return a collection with the specified value removed
	 */
	private static List&lt;?&gt; filterValue(Collection&lt;?&gt; collection, Object value) {
<span class="fc" id="L52">		List&lt;Object&gt; filteredValues = new ArrayList&lt;Object&gt;();</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">		for (Object o : collection) {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">			if (!Objects.equals(o, value)) {</span>
<span class="fc" id="L55">				filteredValues.add(o);</span>
			}
		}
<span class="fc" id="L58">		return filteredValues;</span>
	}

	/**
	 * &lt;p&gt;
	 * Constructs a query which matches the format the SCB API expects. This method performs two
	 * distinct steps:
	 * &lt;/p&gt;
	 * &lt;h1&gt;1. Filter out the null keys&lt;/h1&gt;
	 * &lt;p&gt;
	 * If a key (such as region or year) is defined and all of this key's values are defined as null
	 * it means that all data for this key should be fetched (such as fetching the data for all
	 * available years). By not sending this key at all to the SCB API it recognizes that it should
	 * respond with all data corresponding to this key.
	 * &lt;/p&gt;
	 * &lt;h1&gt;2. Construct the query&lt;/h1&gt;
	 * &lt;p&gt;
	 * For every key in the input map, it creates an entry for this key. It then writes all of the
	 * values corresponding with this key (defined somewhere by using the put-method on the input
	 * map) into this entry. For example, if the input for the key Tid (Swedish for year) contains
	 * the years (values) 2011 and 2012, the resulting entry looks like this:
	 * &lt;p&gt;
	 * { &quot;code&quot;: &quot;Tid&quot;, &quot;selection&quot;: { &quot;filter&quot;: &quot;item&quot;, &quot;values&quot;: [ &quot;2011&quot;, &quot;2012&quot; ] } }
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The method works on the principle of pasting all these blocks together in an orderly fashion
	 * to conform to the SCB API specification.
	 * &lt;/p&gt;
	 * 
	 * @param inputMap
	 *            the input map which contains the keys and the values for every key
	 * @return a string which can be sent as the payload to the SCB API
	 */
	public static String build(Map&lt;String, Collection&lt;?&gt;&gt; inputMap) {
		// 1: Filter out null values
<span class="fc" id="L93">		Map&lt;String, List&lt;?&gt;&gt; filteredMap = new HashMap&lt;String, List&lt;?&gt;&gt;();</span>

<span class="fc bfc" id="L95" title="All 2 branches covered.">		for (Entry&lt;String, Collection&lt;?&gt;&gt; entry : inputMap.entrySet()) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">			if (entry.getValue() != null) {</span>
				// if (new ArrayList&lt;Object&gt;(entry.getValue()).get(0) != null) {
				// filteredMap.put(entry.getKey(), filterValue(entry.getValue(), null));
				// }
<span class="fc" id="L100">				filteredMap.put(entry.getKey(), filterValue(entry.getValue(), null));</span>
			}
		}

		// Approximate a good initial capacity for the string builder
<span class="fc" id="L105">		int size = Math.max(44 + (80 * filteredMap.size()), 256);</span>
<span class="fc" id="L106">		StringBuilder builder = new StringBuilder(size);</span>

		// 2: Construct the query
<span class="fc" id="L109">		builder.append(&quot;{\&quot;query\&quot;: [&quot;);</span>
<span class="fc" id="L110">		int i = 0;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">		for (Entry&lt;String, List&lt;?&gt;&gt; entry : filteredMap.entrySet()) {</span>
<span class="fc" id="L112">			builder.append(&quot;{\&quot;code\&quot;: \&quot;&quot; + entry.getKey() + &quot;\&quot;, \&quot;selection\&quot;: {\&quot;filter\&quot;: \&quot;item\&quot;, \&quot;values\&quot;: [&quot;);</span>
<span class="fc" id="L113">			List&lt;?&gt; values = entry.getValue();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">			for (int j = 0; j &lt; values.size(); j++) {</span>
<span class="fc" id="L115">				builder.append(&quot;\&quot;&quot; + values.get(j) + &quot;\&quot;&quot;);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">				if (j != values.size() - 1) {</span>
<span class="fc" id="L117">					builder.append(',');</span>
				}
			}
<span class="fc" id="L120">			builder.append(&quot;]}}&quot;);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (i != filteredMap.size() - 1) {</span>
<span class="fc" id="L122">				builder.append(',');</span>
			}
<span class="fc" id="L124">			i++;</span>
		}
<span class="fc" id="L126">		builder.append(&quot;],\&quot;response\&quot;: {\&quot;format\&quot;: \&quot;json\&quot;}}&quot;);</span>

<span class="fc" id="L128">		return builder.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>